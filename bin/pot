#! /usr/bin/env ruby

require 'optparse'

require_relative '../lib/config'
require_relative '../lib/pr'
require_relative '../lib/services/github_client.rb'
require_relative '../lib/pr_user_collection'

def main
  if options[:config]
    config.init

    exit(0)
  end

  if options[:register_new]
    config.register_new(options[:registered_name])
  end

  # Use previously saved register
  if options[:registered]
    overwrite_options_with_registered
  end

  if options[:url_only]
    if options[:user].nil?
      puts 'Option "url_only" can be only be used with --user=<the_user>'
      exit(1)
    end

    # Trigger calculations
    user_pr_counts

    if options[:actionable].nil?
      puts pr_urls.map { |pr| pr[:url] }
    else
      pr_urls.each do |pr|
        puts pr[:url] if pr[:actionable] == options[:actionable]
      end
    end

    exit(0)
  end

  if options[:pr_first]
    puts pr_table

    exit(0)
  end

  puts user_table

  if options[:user]
    puts 'Authored:'
    puts '---------'
    puts 'Actionable | Approvals |     +/-     | PR'
    user_prs[:authored].
      sort { |user_pr| user_pr[:actionable] ? 0 : 1 }.
      each do |user_pr|
        state = user_pr[:actionable] ? 'Yes' : 'No'
        state = state.ljust('Actionable |'.size)

        num_of_approvals = user_pr[:num_of_approvals].to_s.rjust('Approvals |'.size / 2 - 2)
        num_of_reviewers = user_pr[:num_of_reviewers].to_s.ljust('Approvals |'.size / 2)

        approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

        additions = user_pr[:additions].to_s.rjust('   +/-     |'.size / 2 - 2)
        deletions = user_pr[:deletions].to_s.ljust('   +/-     |'.size / 2)

        changes_ratio = "#{additions} / #{deletions}"

        puts "#{state} #{approved_to_num_of_reviewers} #{changes_ratio}" \
          " #{user_pr[:title]}"
      end

    puts

    puts 'Reviewing:'
    puts '----------'
    puts 'Actionable | Untouched | Author: Actionables | Approvals |     +/-     | PR'
    user_prs[:reviewing].
      # Putting actionable PRs first and then sorting by author actionables
      # count
      sort do |a, b|
        actionable_score_a = a[:actionable] ? 0 : 1
        actionable_score_b = b[:actionable] ? 0 : 1

        actionables_per_author_a = actionables_per_author[a[:author]]
        actionables_per_author_b = actionables_per_author[b[:author]]

        [actionable_score_a, actionables_per_author_a] <=> [actionable_score_b, actionables_per_author_b]
      end.
      each do |user_pr|
        state = user_pr[:actionable] ? 'Yes' : 'No'
        state = state.ljust('Actionable |'.size)

        untouched = user_pr[:untouched] ? 'Yes' : 'No'
        untouched = untouched.ljust('Untouched |'.size)

        author_actionables = "#{user_pr[:author]}: #{actionables_per_author[user_pr[:author]]}"
        author_actionables = author_actionables.ljust('Author: Actionables |'.size)

        num_of_approvals = user_pr[:num_of_approvals].to_s.rjust('Approvals |'.size / 2 - 2)
        num_of_reviewers = user_pr[:num_of_reviewers].to_s.ljust('Approvals |'.size / 2)

        approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

        additions = user_pr[:additions].to_s.rjust('   +/-     |'.size / 2 - 2)
        deletions = user_pr[:deletions].to_s.ljust('   +/-     |'.size / 2)

        changes_ratio = "#{additions} / #{deletions}"

        puts "#{state} #{untouched} #{author_actionables} " \
          "#{approved_to_num_of_reviewers} #{changes_ratio} #{user_pr[:title]}"
      end
  end
end

def user_prs
  @user_prs ||= { authored: [], reviewing: [] }
end

def pr_urls
  @pr_urls ||= []
end

def options
  @options ||= {}
end

def actionables_per_author
  @actionables_per_author ||= Hash.new { 0 }
end

def untouched_per_author
  @untouched_per_author ||= Hash.new { 0 }
end

OptionParser.new do |opts|
  opts.banner = 'GAT=<your_github_access_token> [--users=some,user,names] [--user=user_name]'

  opts.on('--config', '--configure', 'Outputs only the urls of the PRs authored and the PRs to be reviewed') do
    options[:config] = true
  end

  opts.on('--users=user_names', '--users' , 'Shows only the specified users\' metrics') do |value|
    options[:users] = value
  end

  opts.on('--user=user_name', '--user', 'Shows only the specified user\'s metrics, as well as the PR titles') do |value|
    options[:user] = value
  end

  opts.on('--url-only', 'Outputs only the urls of the PRs authored and the PRs to be reviewed') do
    options[:url_only] = true

    exit(1) if options[:user].nil?
  end

  opts.on('--actionable=actionable', 'Whether to list actionable/non-actionable PR urls (true/false)') do |value|
    if !['true', 'false'].include?(value)
      puts 'Accepted values for actionable: true, false'
      exit(1)
    end

    options[:actionable] = value == 'true'

    exit(1) if options[:url_only].nil?
  end

  opts.on(
    '--github_url=url',
    '--github_url',
    'The github url to use for the requests, defaults to github_url in config file'
  ) do |value|
    options[:github_url] = value
  end

  opts.on(
    '--owner_name=owner_name',
    '--owner_name',
    'The owner name to use in the requests, defaults to owner_name in config file'
  ) do |value|
    options[:owner_name] = value
  end

  opts.on(
    '--repository_names=repository_names',
    '--repository_names',
    'The repository names to search, defaults to repository_names in config file'
  ) do |value|
    options[:repository_names] = value
  end

  opts.on(
    '--register_new=registered_name',
    '--register_new',
    'The name under which current options will be save to be used with --registered <registered_name>'
  ) do |value|
    options[:register_new] = true
    options[:registered_name] = value
  end

  opts.on(
    '--registered=registered_name',
    '--registered',
    'The already registered options under <registered_name> to be used with command'
  ) do |value|
    options[:registered] = true
    options[:registered_name] = value
  end

  opts.on('--pr_first', 'Show list of PRs instead of users') do |value|
    options[:pr_first] = true
  end
end.parse!

def prs
  @prs ||= github_client.prs.map { |pr| Pr.new(pr) }
end

def github_client
  GithubClient.new(options: options, config: config)
end

def user_pr_counts
  return @user_pr_counts if !@user_pr_counts.nil?

  @user_pr_counts = Hash.new { |hash, key| hash[key] = { author: 0, active_reviewer: 0 } }

  prs.each do |pr|
    actionable = nil

    if pr.author == options[:user]
      actionable = pr.author_actionable?
      user_prs[:authored] << {
        title: "#{pr.title} (#{pr.url})",
        actionable: actionable,
        num_of_approvals: pr.num_of_approvals,
        num_of_reviewers: pr.num_of_reviewers,
        additions: pr.additions,
        deletions: pr.deletions
      }
    end

    if pr.active_reviewers.include?(options[:user])
      actionable = pr.reviewer_actionable?(user: options[:user])
      user_prs[:reviewing] << {
        title: "#{pr.title} (#{pr.url})",
        actionable: actionable,
        author: pr.author,
        untouched: pr.untouched_by(options[:user]),
        num_of_approvals: pr.num_of_approvals,
        num_of_reviewers: pr.num_of_reviewers,
        additions: pr.additions,
        deletions: pr.deletions
      }
    end

    # Increment actionable counts
    if pr.author_actionable?
      actionables_per_author[pr.author] += 1
    end

    pr.requested_reviewers.each do |requested_reviewer|
      actionables_per_author[requested_reviewer] += 1

      if pr.untouched_by(requested_reviewer)
        untouched_per_author[requested_reviewer] += 1
      end
    end
    ##

    if options[:url_only] &&
        (pr.active_reviewers.include?(options[:user]) || pr.author == options[:user])
      pr_urls << { url: pr.url, actionable: actionable }
    end

    @user_pr_counts[pr.author][:author] += 1

    pr.active_reviewers.each do |active_reviewer|
      @user_pr_counts[active_reviewer][:active_reviewer] += 1
    end
  end

  @user_pr_counts
end

def user_table
  output = [
    [
      'User' + ' ' * (largest_author_name_size - 'User'.size),
      'Authored',
      'Reviewing',
      'Total',
      'Actionable PRs',
      'Untouched PRs'
    ].join(' | ')
  ]

  output.push('-' * output.first.size)

  pr_users = PrUserCollection.pr_users(
    user_pr_counts: user_pr_counts,
    options: options,
    actionables_per_author: actionables_per_author,
    untouched_per_author: untouched_per_author,
    users_to_include: users_to_include
  )

  pr_users.
    sort do |a, b|
      [
        a.total_count,
        a.actionable_count,
        a.untouched_count
      ] <=> [
        b.total_count,
        b.actionable_count,
        b.untouched_count
      ]
    end.
    each do |user|
      if(user_included?(user.username))
        output.push(
          [
            user.username.ljust(largest_author_name_size),
            user.authored_count.to_s.rjust('Authored | '.size),
            user.reviewing_count.to_s.rjust('Reviewing | '.size),
            user.total_count.to_s.rjust('Total | '.size),
            user.actionable_count.to_s.rjust('Actionable PRs | '.size),
            user.untouched_count.to_s.rjust('Untouched PRs | '.size)
          ].join
        )
      end
    end

  puts output.join("\n")

  nil
end

def pr_table
  included_prs = prs.select { |pr| user_included?(pr.author) }

  if included_prs.size == 0
    puts 'No prs to show'
    return
  end

  date_header = 'Date'.ljust('XXXX-XX-XX'.size) # date format used
  author_header = 'Author'.ljust(largest_author_name_size)

  output = [
    [
      'Number',
      'Title'.ljust(largest_pr_title_size),
      date_header,
      author_header,
      '    +/-    ',
      'Approvals',
      'URL'
    ].join(' | ')
  ]

  prs.
    sort_by(&:created_at).
    each do |pr|
      additions = pr.additions.to_s.rjust('    +/-    |'.size / 2 - 2)
      deletions = pr.deletions.to_s.ljust('    +/-    |'.size / 2)

      num_of_approvals = pr.num_of_approvals.to_s.rjust('Approvals | '.size / 2 - 2)
      num_of_reviewers = pr.num_of_reviewers.to_s.ljust('Approvals | '.size / 2)

      approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

      output.push(
        [
          "##{pr.number}".ljust('Number | '.size),
          pr.title.ljust(largest_pr_title_size + ' | '.size),
          pr.created_at.ljust(date_header.size + ' | '.size),
          pr.author.ljust(largest_author_name_size + ' | '.size),
          "#{additions} / #{deletions}",
          approved_to_num_of_reviewers.ljust('Approvals |'.size),
          pr.url.ljust('URL |'.size)
        ].join
      )
    end

  puts output.join("\n")

  nil
end


def user_included?(user)
  users_to_include.include?(user)
end

def users_to_include
  return @users_to_include if @users_to_include

  users = options[:users].split(',') || []

  @users_to_include = users.push(options[:user]).compact
end

def largest_author_name_size
  return @largest_author_name_size if !@largest_author_name_size.nil?

  @largest_author_name_size = prs.max_by { |pr| pr.author.size }.author.size
end

def largest_pr_title_size
  return @largest_pr_title_size if !@largest_pr_title_size.nil?

  @largest_pr_title_size = prs.
    select { |pr| user_included?(pr.author) }.
    max_by { |pr| pr.title.size }&.title&.size
end

def config
  @config ||= Config.new(options: options)
end

def overwrite_options_with_registered
  if !registered_config
    puts "Registered config #{options[:registered]} was not found"

    exit(1)
  end

  registered_config.keys.each do |key|
    options[key.to_sym] ||= registered_config[key]
  end
end

def registered_config
  config.registered_config(options[:registered_name])
end

main
