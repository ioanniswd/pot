#! /usr/bin/env ruby

require 'optparse'

require_relative '../lib/config'
require_relative '../lib/pr'
require_relative '../lib/services/github_client.rb'
require_relative '../lib/pr_user_collection'
require_relative '../lib/aggregated_data'
require 'terminal-table'

def main
  if options[:config]
    config.init

    exit(0)
  end

  if options[:register_new]
    config.register_new(options[:registered_name])
  end

  # Use previously saved register
  if options[:registered]
    overwrite_options_with_registered
  end

  if options[:url_only]
    if options[:user].nil?
      puts 'Option "url_only" can be only be used with --user=<the_user>'
      exit(1)
    end

    if options[:actionable].nil?
      puts aggregated_data.pr_urls.map { |pr| pr[:url] }
    else
      aggregated_data.pr_urls.each do |pr|
        puts pr[:url] if pr[:actionable] == options[:actionable]
      end
    end

    exit(0)
  end

  puts table_print

  if options[:user]
    table = Terminal::Table.new(
      title: 'Authored',
      headings: [
        'Actionable',
        'Approvals',
        '+/-',
        'PR'
      ]
    )

    aggregated_data.specified_user_prs[:authored].
      sort { |user_pr| user_pr[:actionable] ? 0 : 1 }.
      each do |user_pr|
        num_of_approvals = user_pr[:num_of_approvals]
        num_of_reviewers = user_pr[:num_of_reviewers]

        approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

        additions = user_pr[:additions]
        deletions = user_pr[:deletions]

        changes_ratio = "#{additions} / #{deletions}"

        table.add_row( [
          user_pr[:actionable] ? 'Yes' : 'No',
          approved_to_num_of_reviewers,
          changes_ratio,
          user_pr[:title]
        ])
      end

    puts table

    puts

    table = Terminal::Table.new(
      title: 'Reviewing',
      headings: [
        'Actionable',
        'Untouched',
        'Author: Actionables',
        'Approvals',
        '+/-',
        'PR'
      ]
    )

    aggregated_data.specified_user_prs[:reviewing].
      # Putting actionable PRs first and then sorting by author actionables
      # count
      sort do |a, b|
        actionable_score_a = a[:actionable] ? 0 : 1
        actionable_score_b = b[:actionable] ? 0 : 1

        actionables_count_per_author_a = aggregated_data.actionables_count_per_author[a[:author]]
        actionables_count_per_author_b = aggregated_data.actionables_count_per_author[b[:author]]

        [actionable_score_a, actionables_count_per_author_a] <=> [actionable_score_b, actionables_count_per_author_b]
      end.
      each do |user_pr|
        author_actionables = "#{user_pr[:author]}: #{aggregated_data.actionables_count_per_author[user_pr[:author]]}"

        num_of_approvals = user_pr[:num_of_approvals]
        num_of_reviewers = user_pr[:num_of_reviewers]

        approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

        additions = user_pr[:additions]
        deletions = user_pr[:deletions]

        changes_ratio = "#{additions} / #{deletions}"

        table.add_row( [
          user_pr[:actionable] ? 'Yes' : 'No',
          user_pr[:untouched] ? 'Yes' : 'No',
          author_actionables,
          approved_to_num_of_reviewers,
          changes_ratio,
          user_pr[:title]
        ])
      end

      puts table
  end
end

def options
  @options ||= {}
end

OptionParser.new do |opts|
  opts.banner = 'GAT=<your_github_access_token> [--users=some,user,names] [--user=user_name]'

  opts.on('--config', '--configure', 'Outputs only the urls of the PRs authored and the PRs to be reviewed') do
    options[:config] = true
  end

  opts.on('--users=user_names', '--users' , 'Shows only the specified users\' metrics') do |value|
    options[:users] = value
  end

  opts.on('--user=user_name', '--user', 'Shows only the specified user\'s metrics, as well as the PR titles') do |value|
    options[:user] = value
  end

  opts.on('--url-only', 'Outputs only the urls of the PRs authored and the PRs to be reviewed') do
    options[:url_only] = true

    exit(1) if options[:user].nil?
  end

  opts.on('--actionable=actionable', 'Whether to list actionable/non-actionable PR urls (true/false)') do |value|
    if !['true', 'false'].include?(value)
      puts 'Accepted values for actionable: true, false'
      exit(1)
    end

    options[:actionable] = value == 'true'

    exit(1) if options[:url_only].nil?
  end

  opts.on(
    '--github_url=url',
    '--github_url',
    'The github url to use for the requests, defaults to github_url in config file'
  ) do |value|
    options[:github_url] = value
  end

  opts.on(
    '--owner_name=owner_name',
    '--owner_name',
    'The owner name to use in the requests, defaults to owner_name in config file'
  ) do |value|
    options[:owner_name] = value
  end

  opts.on(
    '--repository_names=repository_names',
    '--repository_names',
    'The repository names to search, defaults to repository_names in config file'
  ) do |value|
    options[:repository_names] = value
  end

  opts.on(
    '--register_new=registered_name',
    '--register_new',
    'The name under which current options will be save to be used with --registered <registered_name>'
  ) do |value|
    options[:register_new] = true
    options[:registered_name] = value
  end

  opts.on(
    '--registered=registered_name',
    '--registered',
    'The already registered options under <registered_name> to be used with command'
  ) do |value|
    options[:registered] = true
    options[:registered_name] = value
  end

  opts.on(
    '--cached',
    'Uses the already cached data from the previous request to speed up the response'
  ) do |value|
    options[:cached] = true
  end
end.parse!

def prs
  @prs ||= github_client.prs.map { |pr| Pr.new(pr) }
end

def github_client
  GithubClient.new(options: options, config: config)
end

def aggregated_data
  @aggregated_data ||= AggregatedData.new(
    prs: prs,
    user: options[:user],
    url_only: options[:url_only]
  )
end

def table_print
  table = Terminal::Table.new(
    headings: [
      'User',
      'Authored',
      'Reviewing',
      'Total',
      ' Total + / - ',
      'Actionables',
      'Actionable  + / -',
      'Untouched'
    ]
  )

  pr_users = PrUserCollection.pr_users(
    aggregated_data: aggregated_data,
    users_to_include: users_to_include
  )

  pr_users.
    sort do |a, b|
      [
        a.total_count,
        a.actionable_count,
        a.untouched_count
      ] <=> [
        b.total_count,
        b.actionable_count,
        b.untouched_count
      ]
    end.
    each do |user|
      if(user_included?(user.username))
        total_additions = user.total_loc[:additions]
        total_deletions = user.total_loc[:deletions]
        total_loc = "#{total_additions} / #{total_deletions}"

        actionable_additions = user.actionable_loc[:additions]
        actionable_deletions = user.actionable_loc[:deletions]
        actionable_loc = "#{actionable_additions} / #{actionable_deletions}"

        table.add_row([
          user.username,
          user.authored_count,
          user.reviewing_count,
          user.total_count.to_s,
          total_loc,
          user.actionable_count,
          actionable_loc,
          user.untouched_count
        ])
      end
    end

  puts table

  nil
end

def user_included?(user)
  users_to_include.include?(user)
end

def users_to_include
  return @users_to_include if @users_to_include

  users = options[:users].split(',') || []

  @users_to_include = users.push(options[:user]).compact
end

def largest_author_name_size
  return @largest_author_name_size if !@largest_author_name_size.nil?

  @largest_author_name_size = prs.max_by { |pr| pr.author.size }.author.size
end

def config
  @config ||= Config.new(options: options)
end

def overwrite_options_with_registered
  if !registered_config
    puts "Registered config #{options[:registered]} was not found"

    exit(1)
  end

  registered_config.keys.each do |key|
    options[key.to_sym] ||= registered_config[key]
  end
end

def registered_config
  config.registered_config(options[:registered_name])
end

main
