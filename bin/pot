#! /usr/bin/env ruby

require 'optparse'

require_relative '../lib/config'
require_relative '../lib/pr'
require_relative '../lib/services/github_client.rb'
require_relative '../lib/pr_user_collection'
require_relative '../lib/aggregated_data'

def main
  if options[:config]
    config.init

    exit(0)
  end

  if options[:register_new]
    config.register_new(options[:registered_name])
  end

  # Use previously saved register
  if options[:registered]
    overwrite_options_with_registered
  end

  if options[:url_only]
    if options[:user].nil?
      puts 'Option "url_only" can be only be used with --user=<the_user>'
      exit(1)
    end

    if options[:actionable].nil?
      puts aggregated_data.pr_urls.map { |pr| pr[:url] }
    else
      aggregated_data.pr_urls.each do |pr|
        puts pr[:url] if pr[:actionable] == options[:actionable]
      end
    end

    exit(0)
  end

  puts table_print

  if options[:user]
    puts 'Authored:'
    puts '---------'
    puts 'Actionable | Approvals |     +/-     | PR'
    aggregated_data.specified_user_prs[:authored].
      sort { |user_pr| user_pr[:actionable] ? 0 : 1 }.
      each do |user_pr|
        state = user_pr[:actionable] ? 'Yes' : 'No'
        state = state.ljust('Actionable |'.size)

        num_of_approvals = user_pr[:num_of_approvals].to_s.rjust('Approvals |'.size / 2 - 2)
        num_of_reviewers = user_pr[:num_of_reviewers].to_s.ljust('Approvals |'.size / 2)

        approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

        additions = user_pr[:additions].to_s.rjust('   +/-     |'.size / 2 - 2)
        deletions = user_pr[:deletions].to_s.ljust('   +/-     |'.size / 2)

        changes_ratio = "#{additions} / #{deletions}"

        puts "#{state} #{approved_to_num_of_reviewers} #{changes_ratio}" \
          " #{user_pr[:title]}"
      end

    puts

    puts 'Reviewing:'
    puts '----------'
    puts 'Actionable | Untouched | Author: Actionables | Approvals |     +/-     | PR'
    aggregated_data.specified_user_prs[:reviewing].
      # Putting actionable PRs first and then sorting by author actionables
      # count
      sort do |a, b|
        actionable_score_a = a[:actionable] ? 0 : 1
        actionable_score_b = b[:actionable] ? 0 : 1

        actionables_count_per_author_a = aggregated_data.actionables_count_per_author[a[:author]]
        actionables_count_per_author_b = aggregated_data.actionables_count_per_author[b[:author]]

        [actionable_score_a, actionables_count_per_author_a] <=> [actionable_score_b, actionables_count_per_author_b]
      end.
      each do |user_pr|
        state = user_pr[:actionable] ? 'Yes' : 'No'
        state = state.ljust('Actionable |'.size)

        untouched = user_pr[:untouched] ? 'Yes' : 'No'
        untouched = untouched.ljust('Untouched |'.size)

        author_actionables = "#{user_pr[:author]}: #{aggregated_data.actionables_count_per_author[user_pr[:author]]}"
        author_actionables = author_actionables.ljust('Author: Actionables |'.size)

        num_of_approvals = user_pr[:num_of_approvals].to_s.rjust('Approvals |'.size / 2 - 2)
        num_of_reviewers = user_pr[:num_of_reviewers].to_s.ljust('Approvals |'.size / 2)

        approved_to_num_of_reviewers = "#{num_of_approvals} / #{num_of_reviewers}"

        additions = user_pr[:additions].to_s.rjust('   +/-     |'.size / 2 - 2)
        deletions = user_pr[:deletions].to_s.ljust('   +/-     |'.size / 2)

        changes_ratio = "#{additions} / #{deletions}"

        puts "#{state} #{untouched} #{author_actionables} " \
          "#{approved_to_num_of_reviewers} #{changes_ratio} #{user_pr[:title]}"
      end
  end
end

def options
  @options ||= {}
end

OptionParser.new do |opts|
  opts.banner = 'GAT=<your_github_access_token> [--users=some,user,names] [--user=user_name]'

  opts.on('--config', '--configure', 'Outputs only the urls of the PRs authored and the PRs to be reviewed') do
    options[:config] = true
  end

  opts.on('--users=user_names', '--users' , 'Shows only the specified users\' metrics') do |value|
    options[:users] = value
  end

  opts.on('--user=user_name', '--user', 'Shows only the specified user\'s metrics, as well as the PR titles') do |value|
    options[:user] = value
  end

  opts.on('--url-only', 'Outputs only the urls of the PRs authored and the PRs to be reviewed') do
    options[:url_only] = true

    exit(1) if options[:user].nil?
  end

  opts.on('--actionable=actionable', 'Whether to list actionable/non-actionable PR urls (true/false)') do |value|
    if !['true', 'false'].include?(value)
      puts 'Accepted values for actionable: true, false'
      exit(1)
    end

    options[:actionable] = value == 'true'

    exit(1) if options[:url_only].nil?
  end

  opts.on(
    '--github_url=url',
    '--github_url',
    'The github url to use for the requests, defaults to github_url in config file'
  ) do |value|
    options[:github_url] = value
  end

  opts.on(
    '--owner_name=owner_name',
    '--owner_name',
    'The owner name to use in the requests, defaults to owner_name in config file'
  ) do |value|
    options[:owner_name] = value
  end

  opts.on(
    '--repository_names=repository_names',
    '--repository_names',
    'The repository names to search, defaults to repository_names in config file'
  ) do |value|
    options[:repository_names] = value
  end

  opts.on(
    '--register_new=registered_name',
    '--register_new',
    'The name under which current options will be save to be used with --registered <registered_name>'
  ) do |value|
    options[:register_new] = true
    options[:registered_name] = value
  end

  opts.on(
    '--registered=registered_name',
    '--registered',
    'The already registered options under <registered_name> to be used with command'
  ) do |value|
    options[:registered] = true
    options[:registered_name] = value
  end
end.parse!

def prs
  @prs ||= github_client.prs.map { |pr| Pr.new(pr) }
end

def github_client
  GithubClient.new(options: options, config: config)
end

def aggregated_data
  @aggregated_data ||= AggregatedData.new(
    prs: prs,
    user: options[:user],
    url_only: options[:url_only]
  )
end

def table_print
  output = [
    [
      'User' + ' ' * (largest_author_name_size - 'User'.size),
      'Authored',
      'Reviewing',
      'Total',
      ' Total + / - ',
      'Actionables',
      'Actionable  + / -',
      'Untouched'
    ].join(' | ')
  ]

  output.push('-' * output.first.size)

  pr_users = PrUserCollection.pr_users(
    aggregated_data: aggregated_data,
    users_to_include: users_to_include
  )

  pr_users.
    sort do |a, b|
      [
        a.total_count,
        a.actionable_count,
        a.untouched_count
      ] <=> [
        b.total_count,
        b.actionable_count,
        b.untouched_count
      ]
    end.
    each do |user|
      if(user_included?(user.username))
        total_header_size = ' Total + / -  | '.size
        total_additions = user.total_loc[:additions].to_s.
          rjust(total_header_size / 2)
        total_deletions = user.total_loc[:deletions].to_s.
          ljust(total_header_size / 2)
        total_loc = "#{total_additions} / #{total_deletions}"

        actionable_header_size = 'Actionable  + / -'.size
        actionable_additions = user.actionable_loc[:additions].to_s.
          rjust(actionable_header_size / 2)
        actionable_deletions = user.actionable_loc[:deletions].to_s.
          ljust(actionable_header_size / 2)
        actionable_loc = "#{actionable_additions} / #{actionable_deletions}"

        output.push(
          [
            user.username.ljust(largest_author_name_size),
            user.authored_count.to_s.rjust('Authored | '.size),
            user.reviewing_count.to_s.rjust('Reviewing | '.size),
            user.total_count.to_s.rjust('Total | '.size),
            total_loc,
            user.actionable_count.to_s.rjust('Actionables'.size),
            actionable_loc,
            user.untouched_count.to_s.rjust('Untouched | '.size)
          ].join
        )
      end
    end

  puts output.join("\n")

  nil
end

def user_included?(user)
  users_to_include.include?(user)
end

def users_to_include
  return @users_to_include if @users_to_include

  users = options[:users].split(',') || []

  @users_to_include = users.push(options[:user]).compact
end

def largest_author_name_size
  return @largest_author_name_size if !@largest_author_name_size.nil?

  @largest_author_name_size = prs.max_by { |pr| pr.author.size }.author.size
end

def config
  @config ||= Config.new(options: options)
end

def overwrite_options_with_registered
  if !registered_config
    puts "Registered config #{options[:registered]} was not found"

    exit(1)
  end

  registered_config.keys.each do |key|
    options[key.to_sym] ||= registered_config[key]
  end
end

def registered_config
  config.registered_config(options[:registered_name])
end

main
